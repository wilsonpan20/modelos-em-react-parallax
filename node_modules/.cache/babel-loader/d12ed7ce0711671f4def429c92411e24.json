{"ast":null,"code":"var _jsxFileName = \"/home/wilson/projetosParticular/yt-react-parallax/src/components/interactive/ScrollableArea.js\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useRef } from 'react';\nimport { useGlobalScroll } from '../../hooks/useGlobalScroll';\nimport { useRect } from '../../hooks/useRect';\nimport { Maths } from '../../utils/Maths';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ScrollableAreaContext = /*#__PURE__*/React.createContext(false);\nexport const ScrollableArea = _ref => {\n  _s();\n\n  let {\n    id = undefined,\n    className = undefined,\n    viewportHeight = 100,\n    clamp = true,\n    debug = false,\n    debugLabel = '',\n    children,\n    style = {},\n    startAtScreenTop = false\n  } = _ref;\n  const ref = useRef(null);\n  const [scrollY, winHeight] = useGlobalScroll();\n  const [initialized, rect] = useRect(ref);\n  const scrollProgress = initialized ? getScrollProgress(scrollY, rect.top, rect.bottom, winHeight, clamp, startAtScreenTop) : 0;\n  useEffect(() => {\n    if (debug) console.log(debugLabel || ref.current && ref.current.id || 'RECT_CALC', `INIT=`, initialized, `TOP=`, rect.top, `BOTTOM=`, rect.bottom);\n  }, [debug, debugLabel, initialized, rect]); // prettier-ignore\n\n  if (debug) console.log(debugLabel || ref.current && ref.current.id || 'SCRL_%=', scrollProgress, 'SCRL_Y=', scrollY);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: id,\n    ref: ref,\n    className: className,\n    style: {\n      minHeight: `${viewportHeight}vh`,\n      backgroundColor: debug ? 'rgba(255, 0, 0, 0.5)' : 'transparent',\n      ...style\n    },\n    children: /*#__PURE__*/_jsxDEV(ScrollableAreaContext.Provider, {\n      value: Number(scrollProgress) || 0,\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 55,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 44,\n    columnNumber: 5\n  }, this);\n};\n/**\n * Get the scroll progress percentage (integer)\n *\n * **WHAT THE VALUES MEAN**\n *\n * 0    => The element's top border is at the very bottom of the viewport (_just out of view_)\n * 0.25 => The element's top border is in the middle of the viewport (_assuming the element is 100% viewport height_)\n * 0.5  => The element's top border is at the very top of the viewport\n * 0.75 => The element's bottom border is in the middle of the viewport (_assuming the element is 100% viewport height_)\n * 1    => The element's bottom border is at the very top of the viewport (_just out of view_)\n *\n * **EXCEPTIONS**\n *\n * 1. The element's top border is at the very top of the document (AND element's bottom border is NOT at the very bottom of the document):\n *    0   => The element's top border is at the very top of the viewport\n *    0.5 => The element's bottom border is in the middle of the viewport (_assuming the element is 100% viewport height_)\n *    1    => The element's bottom border is at the very top of the viewport (_just out of view_)\n * 2. The element's bottom border is at the very bottom of the document (AND element's top border is NOT at the very top of the document):\n *    0    => The element's top border is at the very bottom of the viewport (_just out of view_)\n *    0.5 => The element's top border is in the middle of the viewport (_assuming the element is 100% viewport height_)\n *    1  => The element's top border is at the very top of the viewport\n *\n * TL;DR:\n * - When an element is at the very top of the document, its scrollProgress starts at 0 with it already in view\n * - When an element is at the very bottom of the document, its scrollProgress ends at 1 with it still in view\n */\n\n_s(ScrollableArea, \"V1R+nDh2QYVdru1dAYtFIwh+tLI=\", false, function () {\n  return [useGlobalScroll, useRect];\n});\n\n_c = ScrollableArea;\n\nfunction getScrollProgress() {\n  let scrollY = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let containerTopY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let containerBottomY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let winHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let clamp = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let startAtScreenTop = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (!containerBottomY || containerBottomY - containerTopY <= 0) return -1;\n  const min = startAtScreenTop ? containerTopY : Math.max(containerTopY - winHeight, 0);\n  const max = Math.min(document.body.scrollHeight - winHeight, containerBottomY);\n  const pctProgress = (scrollY - min) / (max - min);\n  if (!clamp) return pctProgress;\n  return Maths.clampVal(pctProgress, 0, 1);\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"ScrollableArea\");","map":{"version":3,"sources":["/home/wilson/projetosParticular/yt-react-parallax/src/components/interactive/ScrollableArea.js"],"names":["React","useEffect","useRef","useGlobalScroll","useRect","Maths","ScrollableAreaContext","createContext","ScrollableArea","id","undefined","className","viewportHeight","clamp","debug","debugLabel","children","style","startAtScreenTop","ref","scrollY","winHeight","initialized","rect","scrollProgress","getScrollProgress","top","bottom","console","log","current","minHeight","backgroundColor","Number","containerTopY","containerBottomY","min","Math","max","document","body","scrollHeight","pctProgress","clampVal"],"mappings":"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","sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport { useGlobalScroll } from '../../hooks/useGlobalScroll';\nimport { useRect } from '../../hooks/useRect';\nimport { Maths } from '../../utils/Maths';\n\nexport const ScrollableAreaContext = React.createContext(false);\n\nexport const ScrollableArea = ({\n  id = undefined,\n  className = undefined,\n  viewportHeight = 100,\n  clamp = true,\n  debug = false,\n  debugLabel = '',\n  children,\n  style = {},\n  startAtScreenTop = false,\n}) => {\n  const ref = useRef(null);\n  const [scrollY, winHeight] = useGlobalScroll();\n  const [initialized, rect] = useRect(ref);\n\n  const scrollProgress = initialized\n    ? getScrollProgress(scrollY, rect.top, rect.bottom, winHeight, clamp, startAtScreenTop)\n    : 0;\n\n  useEffect(() => {\n    if (debug)\n      console.log(\n        debugLabel || (ref.current && ref.current.id) || 'RECT_CALC',\n        `INIT=`,\n        initialized,\n        `TOP=`,\n        rect.top,\n        `BOTTOM=`,\n        rect.bottom,\n      );\n  }, [debug, debugLabel, initialized, rect]);\n\n  // prettier-ignore\n  if (debug) console.log(debugLabel || (ref.current && ref.current.id) || 'SCRL_%=', scrollProgress, 'SCRL_Y=', scrollY);\n\n  return (\n    <div\n      id={id}\n      ref={ref}\n      className={className}\n      style={{\n        minHeight: `${viewportHeight}vh`,\n        backgroundColor: debug ? 'rgba(255, 0, 0, 0.5)' : 'transparent',\n        ...style,\n      }}\n    >\n      {/* prettier-ignore */}\n      <ScrollableAreaContext.Provider value={Number(scrollProgress) || 0}>\n        {children}\n      </ScrollableAreaContext.Provider>\n    </div>\n  );\n};\n\n/**\n * Get the scroll progress percentage (integer)\n *\n * **WHAT THE VALUES MEAN**\n *\n * 0    => The element's top border is at the very bottom of the viewport (_just out of view_)\n * 0.25 => The element's top border is in the middle of the viewport (_assuming the element is 100% viewport height_)\n * 0.5  => The element's top border is at the very top of the viewport\n * 0.75 => The element's bottom border is in the middle of the viewport (_assuming the element is 100% viewport height_)\n * 1    => The element's bottom border is at the very top of the viewport (_just out of view_)\n *\n * **EXCEPTIONS**\n *\n * 1. The element's top border is at the very top of the document (AND element's bottom border is NOT at the very bottom of the document):\n *    0   => The element's top border is at the very top of the viewport\n *    0.5 => The element's bottom border is in the middle of the viewport (_assuming the element is 100% viewport height_)\n *    1    => The element's bottom border is at the very top of the viewport (_just out of view_)\n * 2. The element's bottom border is at the very bottom of the document (AND element's top border is NOT at the very top of the document):\n *    0    => The element's top border is at the very bottom of the viewport (_just out of view_)\n *    0.5 => The element's top border is in the middle of the viewport (_assuming the element is 100% viewport height_)\n *    1  => The element's top border is at the very top of the viewport\n *\n * TL;DR:\n * - When an element is at the very top of the document, its scrollProgress starts at 0 with it already in view\n * - When an element is at the very bottom of the document, its scrollProgress ends at 1 with it still in view\n */\nfunction getScrollProgress(\n  scrollY = 0,\n  containerTopY = 0,\n  containerBottomY = 0,\n  winHeight = 0,\n  clamp = false,\n  startAtScreenTop = false,\n) {\n  if (!containerBottomY || containerBottomY - containerTopY <= 0) return -1;\n\n  const min = startAtScreenTop ? containerTopY : Math.max(containerTopY - winHeight, 0);\n  const max = Math.min(document.body.scrollHeight - winHeight, containerBottomY);\n\n  const pctProgress = (scrollY - min) / (max - min);\n\n  if (!clamp) return pctProgress;\n\n  return Maths.clampVal(pctProgress, 0, 1);\n}\n"]},"metadata":{},"sourceType":"module"}