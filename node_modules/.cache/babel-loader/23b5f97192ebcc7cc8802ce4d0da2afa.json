{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from 'react';\n\nconst defaultRect = () => ({\n  top: undefined,\n  left: undefined,\n  buttom: undefined,\n  right: undefined,\n  width: undefined,\n  height: undefined\n});\n/**\n * Get the rect bounding box for a node excluding any transformations.\n * see: https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms\n */\n\n\nexport const useRect = function () {\n  _s();\n\n  let nodeRef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    current: null\n  };\n  const [initialized, setInitialized] = useState(false);\n  const [rect, setRect] = useState(defaultRect());\n  useEffect(() => {\n    // rect.current = calcPosition(nodeRef.current);\n    setRect(calcPosition(nodeRef.current));\n    setInitialized(true);\n  }, [setInitialized, setRect, nodeRef]);\n\n  const recalculate = () => {\n    const calculated = calcPosition(nodeRef.current);\n    setRect(calculated);\n    return calculated;\n  };\n\n  return [initialized, rect, recalculate];\n};\n\n_s(useRect, \"tDwjcRNGvVPie9h9H/DWut/OEH8=\");\n\nconst calcPosition = node => {\n  if (!node) return defaultRect(); // const style = getComputedStyle(node);\n  // if (!style || !style.transform) return node.getBoundingClientRect();\n\n  let el = node;\n  let offsetLeft = 0;\n  let offsetTop = 0;\n\n  do {\n    offsetLeft += el.offsetLeft;\n    offsetTop += el.offsetTop;\n    el = el.offsetParent;\n  } while (el);\n\n  return {\n    top: offsetTop,\n    left: offsetLeft,\n    bottom: offsetTop + node.offsetHeight,\n    right: offsetLeft + node.offsetWidth\n  };\n}; // const calcPosition2 = (el) => {\n//   if (!el)\n//     return {\n//       top: undefined,\n//       left: undefined,\n//       buttom: undefined,\n//       right: undefined,\n//       width: undefined,\n//       height: undefined,\n//     };\n//   let rect = el.getBoundingClientRect();\n//   let style = getComputedStyle(el);\n//   let tx = style.transform;\n//   if (tx) {\n//     let sx, sy, dx, dy;\n//     if (tx.startsWith('matrix3d(')) {\n//       let ta = tx.slice(9, -1).split(/, /);\n//       sx = +ta[0];\n//       sy = +ta[5];\n//       dx = +ta[12];\n//       dy = +ta[13];\n//     } else if (tx.startsWith('matrix(')) {\n//       let ta = tx.slice(7, -1).split(/, /);\n//       sx = +ta[0];\n//       sy = +ta[3];\n//       dx = +ta[4];\n//       dy = +ta[5];\n//     } else {\n//       return rect;\n//     }\n//     let to = style.transformOrigin;\n//     let x = rect.x - dx - (1 - sx) * parseFloat(to);\n//     let y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(' ') + 1));\n//     let w = sx ? rect.width / sx : el.offsetWidth;\n//     let h = sy ? rect.height / sy : el.offsetHeight;\n//     return {\n//       x: x,\n//       y: y + scrollY,\n//       width: w,\n//       height: h,\n//       top: y + scrollY,\n//       right: x + w,\n//       bottom: y + h + scrollY,\n//       left: x,\n//     };\n//   } else {\n//     return rect;\n//   }\n// };","map":{"version":3,"sources":["/home/wilson/projetosParticular/yt-react-parallax/src/hooks/useRect.js"],"names":["useEffect","useState","defaultRect","top","undefined","left","buttom","right","width","height","useRect","nodeRef","current","initialized","setInitialized","rect","setRect","calcPosition","recalculate","calculated","node","el","offsetLeft","offsetTop","offsetParent","bottom","offsetHeight","offsetWidth"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;;AAEA,MAAMC,WAAW,GAAG,OAAO;AACzBC,EAAAA,GAAG,EAAEC,SADoB;AAEzBC,EAAAA,IAAI,EAAED,SAFmB;AAGzBE,EAAAA,MAAM,EAAEF,SAHiB;AAIzBG,EAAAA,KAAK,EAAEH,SAJkB;AAKzBI,EAAAA,KAAK,EAAEJ,SALkB;AAMzBK,EAAAA,MAAM,EAAEL;AANiB,CAAP,CAApB;AASA;AACA;AACA;AACA;;;AACA,OAAO,MAAMM,OAAO,GAAG,YAAiC;AAAA;;AAAA,MAAhCC,OAAgC,uEAAtB;AAAEC,IAAAA,OAAO,EAAE;AAAX,GAAsB;AACtD,QAAM,CAACC,WAAD,EAAcC,cAAd,IAAgCb,QAAQ,CAAC,KAAD,CAA9C;AACA,QAAM,CAACc,IAAD,EAAOC,OAAP,IAAkBf,QAAQ,CAACC,WAAW,EAAZ,CAAhC;AAEAF,EAAAA,SAAS,CAAC,MAAM;AACd;AACAgB,IAAAA,OAAO,CAACC,YAAY,CAACN,OAAO,CAACC,OAAT,CAAb,CAAP;AACAE,IAAAA,cAAc,CAAC,IAAD,CAAd;AACD,GAJQ,EAIN,CAACA,cAAD,EAAiBE,OAAjB,EAA0BL,OAA1B,CAJM,CAAT;;AAMA,QAAMO,WAAW,GAAG,MAAM;AACxB,UAAMC,UAAU,GAAGF,YAAY,CAACN,OAAO,CAACC,OAAT,CAA/B;AACAI,IAAAA,OAAO,CAACG,UAAD,CAAP;AACA,WAAOA,UAAP;AACD,GAJD;;AAMA,SAAO,CAACN,WAAD,EAAcE,IAAd,EAAoBG,WAApB,CAAP;AACD,CAjBM;;GAAMR,O;;AAmBb,MAAMO,YAAY,GAAIG,IAAD,IAAU;AAC7B,MAAI,CAACA,IAAL,EAAW,OAAOlB,WAAW,EAAlB,CADkB,CAG7B;AACA;;AAEA,MAAImB,EAAE,GAAGD,IAAT;AACA,MAAIE,UAAU,GAAG,CAAjB;AACA,MAAIC,SAAS,GAAG,CAAhB;;AAEA,KAAG;AACDD,IAAAA,UAAU,IAAID,EAAE,CAACC,UAAjB;AACAC,IAAAA,SAAS,IAAIF,EAAE,CAACE,SAAhB;AAEAF,IAAAA,EAAE,GAAGA,EAAE,CAACG,YAAR;AACD,GALD,QAKSH,EALT;;AAOA,SAAO;AACLlB,IAAAA,GAAG,EAAEoB,SADA;AAELlB,IAAAA,IAAI,EAAEiB,UAFD;AAGLG,IAAAA,MAAM,EAAEF,SAAS,GAAGH,IAAI,CAACM,YAHpB;AAILnB,IAAAA,KAAK,EAAEe,UAAU,GAAGF,IAAI,CAACO;AAJpB,GAAP;AAMD,CAvBD,C,CAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { useEffect, useState } from 'react';\n\nconst defaultRect = () => ({\n  top: undefined,\n  left: undefined,\n  buttom: undefined,\n  right: undefined,\n  width: undefined,\n  height: undefined,\n});\n\n/**\n * Get the rect bounding box for a node excluding any transformations.\n * see: https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms\n */\nexport const useRect = (nodeRef = { current: null }) => {\n  const [initialized, setInitialized] = useState(false);\n  const [rect, setRect] = useState(defaultRect());\n\n  useEffect(() => {\n    // rect.current = calcPosition(nodeRef.current);\n    setRect(calcPosition(nodeRef.current));\n    setInitialized(true);\n  }, [setInitialized, setRect, nodeRef]);\n\n  const recalculate = () => {\n    const calculated = calcPosition(nodeRef.current);\n    setRect(calculated);\n    return calculated;\n  };\n\n  return [initialized, rect, recalculate];\n};\n\nconst calcPosition = (node) => {\n  if (!node) return defaultRect();\n\n  // const style = getComputedStyle(node);\n  // if (!style || !style.transform) return node.getBoundingClientRect();\n\n  let el = node;\n  let offsetLeft = 0;\n  let offsetTop = 0;\n\n  do {\n    offsetLeft += el.offsetLeft;\n    offsetTop += el.offsetTop;\n\n    el = el.offsetParent;\n  } while (el);\n\n  return {\n    top: offsetTop,\n    left: offsetLeft,\n    bottom: offsetTop + node.offsetHeight,\n    right: offsetLeft + node.offsetWidth,\n  };\n};\n\n// const calcPosition2 = (el) => {\n//   if (!el)\n//     return {\n//       top: undefined,\n//       left: undefined,\n//       buttom: undefined,\n//       right: undefined,\n//       width: undefined,\n//       height: undefined,\n//     };\n\n//   let rect = el.getBoundingClientRect();\n//   let style = getComputedStyle(el);\n//   let tx = style.transform;\n\n//   if (tx) {\n//     let sx, sy, dx, dy;\n//     if (tx.startsWith('matrix3d(')) {\n//       let ta = tx.slice(9, -1).split(/, /);\n//       sx = +ta[0];\n//       sy = +ta[5];\n//       dx = +ta[12];\n//       dy = +ta[13];\n//     } else if (tx.startsWith('matrix(')) {\n//       let ta = tx.slice(7, -1).split(/, /);\n//       sx = +ta[0];\n//       sy = +ta[3];\n//       dx = +ta[4];\n//       dy = +ta[5];\n//     } else {\n//       return rect;\n//     }\n\n//     let to = style.transformOrigin;\n//     let x = rect.x - dx - (1 - sx) * parseFloat(to);\n//     let y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(' ') + 1));\n//     let w = sx ? rect.width / sx : el.offsetWidth;\n//     let h = sy ? rect.height / sy : el.offsetHeight;\n//     return {\n//       x: x,\n//       y: y + scrollY,\n//       width: w,\n//       height: h,\n//       top: y + scrollY,\n//       right: x + w,\n//       bottom: y + h + scrollY,\n//       left: x,\n//     };\n//   } else {\n//     return rect;\n//   }\n// };\n"]},"metadata":{},"sourceType":"module"}